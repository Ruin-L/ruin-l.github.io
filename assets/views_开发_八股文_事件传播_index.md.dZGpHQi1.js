import{_ as t,C as s,c as i,o as r,aB as o,G as a}from"./chunks/framework.B_fJ6ASn.js";const v=JSON.parse('{"title":"事件传播","description":"","frontmatter":{},"headers":[],"relativePath":"views/开发/八股文/事件传播/index.md","filePath":"views/开发/八股文/事件传播/index.md","lastUpdated":1764579601000}'),p={name:"views/开发/八股文/事件传播/index.md"};function d(c,n,u,g,b,h){const e=s("NolebaseGitContributors"),l=s("NolebaseGitChangelog");return r(),i("div",null,[n[0]||(n[0]=o(`<h1 id="事件传播" tabindex="-1">事件传播 <a class="header-anchor" href="#事件传播" aria-label="Permalink to &quot;事件传播&quot;">​</a></h1><p>在 JavaScript 中， <strong>事件捕获（Capturing）</strong> 和 <strong>事件冒泡（Bubbling）</strong> 是事件传播的两个核心机制，共同构成 DOM 事件流的完整生命周期。他的事件流有点像钓鱼，捕获阶段相当于扔鱼钩，目标阶段相当于鱼儿上钩，冒泡阶段相当于鱼儿被钓处水面以下是两者的详细解释及对比：</p><h2 id="一、事件传播的三个阶段" tabindex="-1">一、事件传播的三个阶段 <a class="header-anchor" href="#一、事件传播的三个阶段" aria-label="Permalink to &quot;一、事件传播的三个阶段&quot;">​</a></h2><p>事件触发后，会依次经历以下三个阶段：</p><ol><li><strong>捕获阶段（Capturing Phase）</strong></li></ol><ul><li><p><strong>传播方向</strong> ：从最外层祖先元素（如 <code>document</code>或 <code>window</code>）逐级向下传递，直到目标元素。</p></li><li><p><strong>特点</strong> ：允许在事件到达目标前进行预处理（如权限验证、全局拦截）。</p></li><li><p><strong>启用方式</strong> ：通过 <code>addEventListener</code>的第三个参数设为 <code>true</code>，例如：</p><p><code>element.addEventListener(&#39;click&#39;, handler, true);</code></p></li></ul><ol><li><strong>目标阶段（Target Phase）</strong></li></ol><ul><li><strong>触发位置</strong> ：事件到达实际绑定的元素（即 <code>event.target</code>）。</li><li><strong>特点</strong> ：无论监听器注册在捕获还是冒泡阶段，此时都会执行目标元素上的监听器。</li><li><strong>注意</strong> ：若多个监听器绑定在同一元素，按注册顺序执行。</li></ul><ol><li><strong>冒泡阶段（Bubbling Phase）</strong></li></ol><ul><li><strong>传播方向</strong> ：从目标元素逐级向上传播至根节点。</li><li><strong>特点</strong> ：默认的事件传播方式，允许父元素统一处理子元素事件（事件委托）。</li><li><strong>启用方式</strong> ：<code>addEventListener</code>第三个参数设为 <code>false</code>（默认值）。</li></ul><hr><h2 id="二、捕获与冒泡的核心区别" tabindex="-1">二、捕获与冒泡的核心区别 <a class="header-anchor" href="#二、捕获与冒泡的核心区别" aria-label="Permalink to &quot;二、捕获与冒泡的核心区别&quot;">​</a></h2><table tabindex="0"><thead><tr><th><strong>特性</strong></th><th><strong>捕获阶段</strong></th><th><strong>冒泡阶段</strong></th></tr></thead><tbody><tr><td><strong>传播方向</strong></td><td>外层 → 内层（根到目标）</td><td>内层 → 外层（目标到根）</td></tr><tr><td><strong>默认行为</strong></td><td>需显式启用（<code>useCapture: true</code>）</td><td>默认启用</td></tr><tr><td><strong>典型用途</strong></td><td>全局拦截、预处理</td><td>事件委托、动态元素处理</td></tr><tr><td><strong>执行顺序</strong></td><td>先于目标阶段和冒泡阶段</td><td>在捕获阶段之后执行</td></tr></tbody></table><hr><h2 id="三、代码示例与行为分析" tabindex="-1">三、代码示例与行为分析 <a class="header-anchor" href="#三、代码示例与行为分析" aria-label="Permalink to &quot;三、代码示例与行为分析&quot;">​</a></h2><h4 id="示例-1-捕获与冒泡的触发顺序" tabindex="-1">示例 1：捕获与冒泡的触发顺序 <a class="header-anchor" href="#示例-1-捕获与冒泡的触发顺序" aria-label="Permalink to &quot;示例 1：捕获与冒泡的触发顺序&quot;">​</a></h4><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&lt;div id=&quot;parent&quot;&gt;</span></span>
<span class="line"><span>  Parent</span></span>
<span class="line"><span>  &lt;div id=&quot;child&quot;&gt;Child&lt;/div&gt;</span></span>
<span class="line"><span>&lt;/div&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// 捕获阶段监听</span></span>
<span class="line"><span>parent.addEventListener(&#39;click&#39;, () =&gt; console.log(&#39;捕获: Parent&#39;), true);</span></span>
<span class="line"><span>child.addEventListener(&#39;click&#39;, () =&gt; console.log(&#39;捕获: Child&#39;), true);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 冒泡阶段监听</span></span>
<span class="line"><span>parent.addEventListener(&#39;click&#39;, () =&gt; console.log(&#39;冒泡: Parent&#39;), false);</span></span>
<span class="line"><span>child.addEventListener(&#39;click&#39;, () =&gt; console.log(&#39;冒泡: Child&#39;), false);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p><strong>点击 <code>child</code>时输出顺序</strong> ：</p><ol><li>捕获阶段：<code>捕获: Parent</code>→ <code>捕获: Child</code></li><li>目标阶段：无（未绑定目标阶段监听器）</li><li>冒泡阶段：<code>冒泡: Child</code>→ <code>冒泡: Parent</code></li></ol><hr><h4 id="示例-2-阻止事件传播" tabindex="-1">示例 2：阻止事件传播 <a class="header-anchor" href="#示例-2-阻止事件传播" aria-label="Permalink to &quot;示例 2：阻止事件传播&quot;">​</a></h4><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>child.addEventListener(&#39;click&#39;, (e) =&gt; {</span></span>
<span class="line"><span>  e.stopPropagation(); // 阻止后续冒泡</span></span>
<span class="line"><span>  console.log(&#39;Child 事件被阻止冒泡&#39;);</span></span>
<span class="line"><span>});</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul><li><strong>效果</strong> ：点击 <code>child</code>时，仅触发 <code>Child</code>的监听器，父元素的冒泡监听器不再执行。</li></ul><hr><h2 id="四、实际应用场景" tabindex="-1">四、实际应用场景 <a class="header-anchor" href="#四、实际应用场景" aria-label="Permalink to &quot;四、实际应用场景&quot;">​</a></h2><ol><li><strong>事件委托（冒泡的应用）</strong></li></ol><ul><li><p>将事件监听器绑定到父元素，通过 <code>event.target</code>判断具体触发元素，减少内存占用。</p></li><li><p>示例：动态列表项点击处理：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>document.querySelector(&#39;ul&#39;).addEventListener(&#39;click&#39;, (e) =&gt; {</span></span>
<span class="line"><span>  if (e.target.tagName === &#39;LI&#39;) {</span></span>
<span class="line"><span>    console.log(&#39;点击了列表项:&#39;, e.target.textContent);</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>});</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div></li></ul><ol><li><p><strong>捕获阶段的拦截</strong></p><ul><li><p>在事件到达目标前进行权限验证或全局处理：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>document.addEventListener(&#39;click&#39;, (e) =&gt; {</span></span>
<span class="line"><span>  if (e.target.closest(&#39;.unsafe&#39;)) {</span></span>
<span class="line"><span>    e.stopPropagation(); // 阻止危险操作冒泡</span></span>
<span class="line"><span>    alert(&#39;操作被拦截！&#39;);</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}, true);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div></li></ul></li></ol><hr><h2 id="五、注意事项" tabindex="-1">五、注意事项 <a class="header-anchor" href="#五、注意事项" aria-label="Permalink to &quot;五、注意事项&quot;">​</a></h2><ol><li><strong>兼容性</strong> ：</li></ol><ul><li>旧版 IE（&lt;IE9）使用 <code>attachEvent</code>且仅支持冒泡，需通过 <code>event.cancelBubble = true</code>阻止冒泡。</li></ul><ol><li><strong>性能优化</strong> ：</li></ol><ul><li>避免在捕获阶段频繁操作 DOM，可能影响性能。</li></ul><ol><li><strong>事件阶段判断</strong> ：</li></ol><ul><li>通过 <code>event.eventPhase</code>可获取当前阶段（1: 捕获，2: 目标，3: 冒泡）。</li></ul><hr><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><ul><li><strong>捕获</strong> ：自外向内传播，适合全局拦截和预处理。</li><li><strong>冒泡</strong> ：自内向外传播，适合事件委托和简化代码。</li><li><strong>目标阶段</strong> ：事件实际触发的位置，所有监听器在此阶段执行。</li></ul><p>合理利用这两个机制，可以优化事件处理逻辑，提升代码可维护性和性能。</p>`,41)),a(e),a(l)])}const k=t(p,[["render",d]]);export{v as __pageData,k as default};

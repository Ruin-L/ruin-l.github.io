import{_ as t,C as o,c as s,o as a,aB as n,G as l}from"./chunks/framework.B_fJ6ASn.js";const _=JSON.parse('{"title":"promise","description":"","frontmatter":{},"headers":[],"relativePath":"views/开发/八股文/promise/index.md","filePath":"views/开发/八股文/promise/index.md","lastUpdated":1764818257000}'),c={name:"views/开发/八股文/promise/index.md"};function d(m,e,u,g,P,h){const i=o("NolebaseGitContributors"),r=o("NolebaseGitChangelog");return a(),s("div",null,[e[0]||(e[0]=n('<h1 id="promise" tabindex="-1">promise <a class="header-anchor" href="#promise" aria-label="Permalink to &quot;promise&quot;">​</a></h1><ul><li>定义：是一个 js 用于处理异步操作的构造函数，他有三种状态分别是（<strong>pending</strong>）初始状态，<strong>fulfilled</strong>（成功），rejected（失败），一旦状态发生变化便无法改变。</li><li>作用：我们更方便地使用链式调用处理异步任务，避免回调地狱的问题。</li><li>静态方法（9 个）：resolve()、reject()、all()、race()、allSettled()、any()、try()</li><li>回调函数（3 个）.then()、.catch()、.finally()</li></ul><p>以下是完整列表：</p><hr><h2 id="一、实例方法-通过-promise-实例调用" tabindex="-1"><strong>一、实例方法</strong> （通过 Promise 实例调用） <a class="header-anchor" href="#一、实例方法-通过-promise-实例调用" aria-label="Permalink to &quot;**一、实例方法** （通过 Promise 实例调用）&quot;">​</a></h2><ol><li><strong><code>.then(onFulfilled, onRejected)</code></strong></li></ol><ul><li>添加处理程序：成功时执行 <code>onFulfilled</code>，失败时执行 <code>onRejected</code>。</li><li>返回一个新的 Promise（支持链式调用）。</li></ul><ol><li><strong><code>.catch(onRejected)</code></strong></li></ol><ul><li>专门处理失败的回调函数（等价于 <code>.then(null, onRejected)</code>）。</li><li>返回一个新的 Promise。</li></ul><ol><li><strong><code>.finally(onFinally)</code></strong></li></ol><ul><li>无论 Promise 成功或失败都会执行的清理逻辑。</li><li>返回一个新的 Promise（结果状态与原 Promise 一致）。</li></ul><hr><h2 id="二、静态方法-通过-promise构造函数调用" tabindex="-1"><strong>二、静态方法</strong> （通过 <code>Promise</code>构造函数调用） <a class="header-anchor" href="#二、静态方法-通过-promise构造函数调用" aria-label="Permalink to &quot;**二、静态方法** （通过 `Promise`构造函数调用）&quot;">​</a></h2><ol><li><strong><code>Promise.resolve(value)</code></strong></li></ol><ul><li>返回一个已解决的 Promise（值为 <code>value</code>）。</li></ul><ol start="2"><li><strong><code>Promise.reject(reason)</code></strong></li></ol><ul><li>返回一个已拒绝的 Promise（原因为 <code>reason</code>）。</li></ul><ol start="3"><li><strong><code>Promise.all(iterable)</code></strong></li></ol><ul><li>接收一个 Promise 可迭代对象，全部成功时返回结果数组；任一失败时立即拒绝。</li></ul><ol start="4"><li><strong><code>Promise.allSettled(iterable)</code></strong></li></ol><ul><li>等待所有 Promise 完成（无论成功/失败），返回包含状态的对象数组。</li></ul><ol start="5"><li><strong><code>Promise.race(iterable)</code></strong></li></ol><ul><li>返回第一个敲定（成功或失败）的 Promise 的结果。</li></ul><ol start="6"><li><strong><code>Promise.any(iterable)</code></strong></li></ol><ul><li>返回第一个成功的 Promise 的结果；若全部失败则拒绝（返回 <code>AggregateError</code>）。</li></ul><ol start="7"><li><strong><code>Promise.try()</code></strong></li></ol><ul><li>是一种将同步或异步函数的执行结果封装为 Promise 的方法，无论函数是返回值、抛出错误，还是返回一个 Promise，都能统一处理。</li></ul><hr><h2 id="关键区别" tabindex="-1">关键区别 <a class="header-anchor" href="#关键区别" aria-label="Permalink to &quot;关键区别&quot;">​</a></h2><ul><li><strong>实例方法</strong> ：用于操作单个 Promise 实例（如 <code>.then()</code>处理结果）。</li><li><strong>静态方法</strong> ：用于批量操作多个 Promise（如 <code>Promise.all()</code>并行处理）。</li></ul><blockquote><p>⚠️ 注意：这些方法都是 <strong>Promise 对象自身的方法</strong> ，而非回调函数（如 <code>resolve/reject</code>是创建 Promise 时的参数函数，不属于 Promise 的方法）。</p></blockquote>',31)),l(i),l(r)])}const b=t(c,[["render",d]]);export{_ as __pageData,b as default};
